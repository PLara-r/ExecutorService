# ExecutorService

главный вывод
Так как Callableподдерживает тип возврата при использовании с ExecutorService, он часто предпочтительнее, чем Runnableпри использовании ConcurrencyAPI.
Проверенные исключения в Callable и Runnable
Помимо наличия возвращаемого типа, Callableинтерфейс также поддерживает проверенные исключения, тогда как Runnableинтерфейс не имеет встроенного try/catchблока.
При условии наличия экземпляра ExecutorServicenamed service, какие из следующих строк кода будут или не будут компилироваться?
service.submit(() -> {Thread.sleep(1000); return null;});
service.submit(() -> {Thread.sleep(1000);});
Первая строка будет компилироваться, а вторая - нет. Почему? Напомним, что Thread.sleep()выбрасывает проверено InterruptedException.
Поскольку первое лямбда-выражение имеет тип возвращаемого значения, компилятор обрабатывает его как Callableвыражение, которое поддерживает проверенные исключения.
Второе лямбда-выражение не возвращает значение; следовательно, компилятор обрабатывает это как Runnableвыражение. 
Поскольку Runnableметоды не поддерживают проверенные исключения, компилятор сообщит об ошибке, пытаясь скомпилировать этот фрагмент кода.

1) Создание потоков с помощью ExecutorService

С объявлением об ConcurrencyAPI Java представила ExecutorService, которая создает и управляет потоками для вас.
Сначала вы получаете экземпляр ExecutorServiceинтерфейса, а затем отправляете задачи обслуживания для обработки.
Инфраструктура включает в себя множество полезных функций, таких как пул потоков и планирование, которые было бы сложно реализовать в каждом проекте. 
Поэтому рекомендуется использовать эту платформу в любое время, когда вам нужно создать и выполнить отдельную задачу, даже если вам нужен только один поток.  
Представляем однопоточного исполнителя
Так ExecutorServiceкак это интерфейс, как вы получаете его экземпляр? ConcurrencyAPI включает Executorsкласс фабрики ,
которые могут быть использованы для создания экземпляров ExecutorServiceобъекта. Как вы, возможно, помните из главы 2 «Шаблоны и принципы проектирования»,
фабричный шаблон является творческим шаблоном, в котором основные детали реализации создания объекта скрыты от нас. Вы увидите снова заводской шаблон,
использованный в главе 9 «NIO.2».
Давайте начнем с простого примера использования newSingleThreadExecutor()метода для получения ExecutorServiceэкземпляра и execute()метода для выполнения асинхронных задач:

import java.util.concurrent.*;
public class ZooInfo {  
 public static void main(String[] args) {  
    ExecutorService service = null;    
  try {     
    service = Executors.newSingleThreadExecutor();   
      System.out.println("begin"); 
        service.execute(() -> System.out.println("Printing zoo inventory"));  
       service.execute(() -> {for(int i=0; i<3; i++)      
      System.out.println("Printing record: "+i);}  
       );    
     service.execute(() -> System.out.println("Printing zoo inventory"));     
    System.out.println("end");  
} finally {      
   if(service != null) service.shutdown();    
  }   
}}
Как вы можете заметить, что это просто переписывают наших предыдущих классов для использования

Runnable-На лямбда - выражений и в ExecutorServiceэкземпляр.

В этом примере мы использовали newSingleThreadExecutor()метод, который является самым простым, ExecutorServiceкоторый мы могли создать.
В отличие от нашего предыдущего примера, в котором у нас было три дополнительных потока для вновь созданных задач, в этом примере используется только один, 
что означает, что потоки упорядочат свои результаты. Например, следующее является возможным выводом для этого фрагмента кода:

Begin
Printing zoo inventory
Printing record: 0
Printing record: 1
End
Printing record: 2
Printing zoo inventory

При использовании однопотокового исполнителя результаты гарантированно будут выполнены в том порядке, в котором они добавлены в службу исполнителя.
Обратите внимание, что endтекст выводится, когда наши задачи исполнения потоков все еще выполняются.
Это связано с тем, что main()метод все еще является независимым потоком от ExecutorServiceи может выполнять задачи во время работы другого потока.

Выполнение нескольких задач
В предыдущем примере вполне возможно, что все три задачи были отправлены на выполнение еще до того, как была запущена первая задача.
В этом случае однопотоковый исполнитель поставит задачи в очередь и дождется завершения предыдущей задачи перед выполнением следующей задачи.
Хотя задачи гарантированно выполняются в том порядке, в котором они представлены для однопотокового исполнителя, вы избегаете полагаться на это поведение 
для упорядочения событий. Как вы увидите позже в этой главе, когда мы увеличиваем количество потоков в службе executor, эта гарантия исчезает.

  Завершение работы исполнителя
Как только вы закончили использовать потоковый исполнитель, важно, чтобы вы вызвали shutdown()метод. Исполнитель потока создает поток, не являющийся демоном,
для первой задачи, которая выполняется, поэтому отказ от вызова shutdown()приведет к тому, что ваше приложение никогда не завершится.

2)Представляем Callable

Когда ConcurrencyAPI был выпущен в Java 5, java.util.concurrent.Callableбыл добавлен новый интерфейс, или, Callableдля краткости, что аналогично тому,
Runnableчто его call()метод возвращает значение и может выдавать проверенное исключение. Как вы помните из определения Runnable,
run()метод возвращает voidи не может генерировать какие-либо проверенные исключения. Наряду с этим Runnable, Callableбыл также сделан функциональный интерфейс в Java 8. 
Ниже приведено определение Callableинтерфейса:
@FunctionalInterface public interface Callable<V> {
   V call() throws Exception;
}
Callable Интерфейс был введен в качестве альтернативы Runnableинтерфейсу, так как это позволяет более подробно , 
чтобы быть легко извлечены из задачи после того, как он будет завершен. ExecutorServiceВключает в себя перегруженную версию submit()метода ,
который принимает Callableобъект и возвращает общий Future<T>объект.
Неоднозначные лямбда-выражения: вызываемый против поставщика
Из главы 4 вы можете помнить, что Callableфункциональный интерфейс сильно напоминает Supplierфункциональный интерфейс,
поскольку они оба не принимают аргументов и возвращают универсальный тип. Единственное отличие состоит в том, что метод Callableможет выдавать проверенный Exception. 
Как вы скажете лямбда-выражения для этих двух отдельно? Ответ иногда не получается. Рассмотрим следующий пример,
в котором используется одно и то же лямбда-выражение для трех разных вызовов методов:public class AmbiguousLambdaSample {

public class AmbiguousLambdaSample { 
  public static void useCallable(Callable<Integer> expression) {}
   public static void useSupplier(Supplier<Integer> expression) {}  
 public static void use(Supplier<Integer> expression) {} 
  public static void use(Callable<Integer> expression) {} 
  public static void main(String[] args) {  
    useCallable(() -> {throw new IOException();});  // COMPILES 
     useSupplier(() -> {throw new IOException();});  // DOES NOT COMPILE   
   use(() -> {throw new IOException();});          // DOES NOT COMPILE 
  }}
Первая строка main()метода компилируется, так как Callableразрешено генерировать проверенные исключения. Вторая строка main()метода не компилируется, так как Supplierне поддерживает проверенные исключения.
Как насчет последней строки? use()Метод перегружен , чтобы принимать как Callableи Supplierпараметры. Компилятор не принимает во внимание тот факт, что тело лямбда-выражения вызывает исключение; следовательно, он не знает, как отличить их друг от друга. Как вы уже могли догадаться, когда компилятор не знает, что делать, он сообщает об ошибке и не компилируется. Когда компилятор не может назначить функциональный интерфейс лямбда-выражению, это называется неоднозначным лямбда-выражением .
Обратите внимание, что неоднозначность может быть решена с явным приведением. Например, следующая исправленная строка кода компилируется:
use((Callable<Integer>)() -> {throw new IOException("");});  // COMPILES
При явном приведении лямбда-выражение больше не является неоднозначным, и компилятор может обработать его без проблем.
В отличие от того Runnable, в котором get()методы всегда возвращаются null, get()методы Futureобъекта возвращают соответствующий универсальный тип или null.


2)!!!

Давайте посмотрим на пример, используя Callable:

import java.util.concurrent.*;
public class AddData { 
  public static void main(String[] args) throws InterruptedException,      
      ExecutionException {    
  ExecutorService service = null;   
   try {     
    service = Executors.newSingleThreadExecutor(); 
        Future<Integer> result = service.submit(() -> 30+11);    
     System.out.println(result.get());   
   } finally {  
       if(service != null) service.shutdown(); 
     } 
  }}
  
  //41
  
Теперь мы можем получить и распечатать вывод Callableрезультатов, 41в этом примере. Результаты также могли быть получены с использованием Runnableнекоторого общего,
возможно static, объекта, хотя это решение, на которое опирается Callable, намного проще и легче следовать.
Так как Callableподдерживает тип возврата при использовании с ExecutorService, он часто предпочтительнее, чем Runnableпри использовании ConcurrencyAPI.

Тем не менее, в этой главе мы используем оба интерфейса, поскольку они взаимозаменяемы в ситуациях, когда лямбда-выражение не выдает исключение, а тип возврата отсутствует.
Проверенные исключения в Callable и Runnable
Помимо наличия возвращаемого типа, Callableинтерфейс также поддерживает проверенные исключения, тогда как Runnableинтерфейс не имеет встроенного try/catchблока.
При условии наличия экземпляра ExecutorServicenamed service, какие из следующих строк кода будут или не будут компилироваться?
service.submit(() -> {Thread.sleep(1000); return null;});
service.submit(() -> {Thread.sleep(1000);});
Первая строка будет компилироваться, а вторая - нет. Почему? Напомним, что Thread.sleep()выбрасывает проверено InterruptedException.
Поскольку первое лямбда-выражение имеет тип возвращаемого значения, компилятор обрабатывает его как Callableвыражение, которое поддерживает проверенные исключения.
Второе лямбда-выражение не возвращает значение; следовательно, компилятор обрабатывает это как Runnableвыражение. 
Поскольку Runnableметоды не поддерживают проверенные исключения, компилятор сообщит об ошибке, пытаясь скомпилировать этот фрагмент кода.

В ожидании завершения всех задач

После отправки набора задач исполнителю потока обычно ждут результатов. Как вы видели в предыдущих разделах,
одним из решений является вызов get()каждого Futureобъекта, возвращаемого submit()методом.
Если нам не нужны результаты задач и мы завершили работу с нашим исполнителем потоков, есть более простой подход.
Во-первых, мы закрыли исполнитель потока, используя shutdown()метод. Далее мы используем awaitTermination(long timeout, TimeUnit unit)метод, 
доступный для всех потоковисполнители. Метод ожидает указанное время для завершения всех задач, возвращаясь раньше,
если все задачи завершены или InterruptedExceptionобнаружено. Вы можете увидеть пример этого в следующем фрагменте кода:
ExecutorService service = null;
try { 
  service = Executors.newSingleThreadExecutor(); 
  // Add tasks to the thread executor 
  ...
} finally {  
 if(service != null) service.shutdown();
}
if(service != null) { 
  service.awaitTermination(1, TimeUnit.MINUTES); 
  // Check whether all tasks are finished   
if(service.isTerminated())   
   System.out.println("All tasks finished");
   else   
   System.out.println("At least one task is still running");
}
В этом примере мы отправляем ряд задач исполнителю потока, а затем закрываем его и ожидаем результатов в течение одной минуты.
Обратите внимание, что мы можем вызвать isTerminated()после завершения awaitTermination()метода, чтобы подтвердить, что все задачи действительно завершены. 

3) методы

Для экзамена вы должны знать, что на shutdown()самом деле не останавливает задачи, которые уже были отправлены исполнителю потока.
Что если вы хотите отменить все выполняющиеся и предстоящие задачи? ExecutorServiceПредоставляет метод shutdownNow(),
который пытается остановить все запущенные задачи и отбрасываются все , что не были начаты еще. Обратите внимание, что shutdownNow() пытается остановить все запущенные задачи.
Можно создать поток, который никогда не прекратится, поэтому любая попытка прервать его может быть проигнорирована.
Наконец, shutdownNow()возвращает List<Runnable>задачи, которые были отправлены исполнителю потока, но никогда не запускались.
Окончательно закрываем ветку
Как вы узнали из главы 6, ресурсы, такие как исполнители потоков, должны быть правильно закрыты для предотвращения утечек памяти. К сожалению,
ExecutorServiceинтерфейс не реализуется AutoCloseable, поэтому вы не можете использовать оператор try-with-resources. Вывсе еще может использовать finallyблок,
как мы делаем в этой главе. Хотя это и не требуется, это считается хорошей практикой.
ExecutorService service = null;
try { 
  service = Executors.newSingleThreadExecutor();   
// Add tasks to thread executor  
 …
} finally { 
  if(service != null) service.shutdown();
}
Хотя это решение работает для исполнителей потоков, которые используются один раз и выбрасываются, оно не работает для исполнителей потоков,
которые являются постоянными на протяжении всего жизненного цикла приложения. Например, вы можете создать staticэкземпляр исполнителя потока и сделать так,
чтобы все процессы использовали его совместно.
В таком сценарии вам необходимо определить staticметод, который можно вызывать в любое время, когда пользователь сообщает о своем желании выйти из программы. 
Помните, что сбой при закрытии исполнителя потока после создания хотя бы одного потока приведет к зависанию программы.  
Отправка задач
Вы можете отправить задачи в ExecutorServiceэкземпляр несколькими способами. Первый метод, который мы представили, execute()унаследован от Executorинтерфейса,
который ExecutorServiceрасширяет интерфейс. execute()Метод принимает Runnableлямбда - выражение или экземпляр и завершает задачу асинхронно.
Поскольку возвращаемый тип метода - voidэто, он ничего не говорит нам о результате задачи. Он считается методом «забей и забудь»,
так как после его отправки результаты не будут напрямую доступны вызывающему потоку.
К счастью, авторы Java добавили submit()методы к ExecutorServiceинтерфейсу, которые, как и другие execute(), могут использоваться для асинхронного выполнения задач. 
В отличие execute(), однако, submit()возвращает Futureобъект, который можно использовать для определения того, завершена ли задача.
Его также можно использовать для возврата универсального объекта результата после завершения задачи.
В таблице 7.2 показаны пять методов, включая execute()два submit(), которые вы должны знать для сдачи экзамена.

Таблица 7.2 ExecutorService методы
Method Name                                                                	Описание
void execute(Runnable command)                                             	Выполняет Runnableзадачу в какой-то момент в будущем
Future<?> submit(Runnable task)                                        	Выполняет Runnableзадачу в какой-то момент в будущем и возвращает Futureпредставление,
                                                                           представляющее задачу
<T> Future<T> submit(Callable<T> task)                     	Выполняет Callableзадачу в какой-то момент в будущем и возвращает Futureпредставление,
                                                                        представляющее ожидающие результаты задачи
<T> List<Future<T>> invokeAll( Collection<? extends Callable<T>> tasks) throws InterruptedException	     Выполнение поставленных задач, синхронно возвращаются результаты 
                                                           всех задач , как Collectionиз Futureобъектов, в том же порядке , как они были в оригинальной коллекции
<T> T invokeAny( Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException         Выполняет заданные задачи, синхронно возвращая результат 
                                                                                   одной из выполненных задач, отменяя все незавершенные задачи

На практике использование submit()метода очень похоже на использование execute()метода, за исключением того, что submit()метод возвращает Futureобъект,
который можно использовать, чтобы определить, завершено ли выполнение задачи. Не волнуйтесь, если вы не видели Futureили Callableраньше; 
мы обсудим их подробно в ближайшее время.
Задачи отправки : execute () против submit ()
Как вы , возможно, заметили, execute()и submit()методы почти идентичны при применении к Runnableвыражениям. submit()Метод имеет очевидное преимущество делать 
точно то же самое execute()делает, но с объектом возврата , который может быть использован для отслеживания результата. Из - за этого преимущества и тот факт ,
что execute()не поддерживает Callableвыражения, как правило, предпочитают submit()более execute(), даже если вы не храните Futureссылку.
Поэтому мы используем submit()в большинстве примеров в этой главе.
Для экзамена, вы должны быть знакомы с обоими execute()и submit(), но в вашем собственном коде мы рекомендуем submit()более , execute()когда это возможно. 
 Отправка коллекций задач
Последние два метода , приведенные в таблице 7.2 , которые вы должны знать для экзамена invokeAll()и invokeAny(). Оба эти метода принимают Collectionобъект,
содержащий список задач для выполнения. Оба эти метода также выполняются синхронно. Под синхронным мы подразумеваем, что в отличие от других методов,
используемых для передачи задач исполнителю потока, эти методы будут ждать, пока результаты не станут доступны, прежде чем вернуть управление в программу-оболочку.
invokeAll()Метод выполняет все задачи в представленной коллекции и возвращает Listупорядоченных Futureобъектов, с один Futureобъект , 
соответствующий каждой представленной задачи, в том порядке , в котором они находились в оригинальной коллекции. 
Несмотря на то, что Future.isDone()возвращается trueдля каждого элемента в возвращаемом List, задача могла бы завершиться нормально или выдать исключение.
invokeAny()Метод выполняет набор задач и возвращает результат одной из задач , которые успешно завершают выполнение, отменяя все незавершенные задачи.
Хотя часто возвращается первая задача, которую нужно выполнить, это поведение не гарантируется, так как этот метод может вернуть любую завершенную задачу.
Наконец, invokeAll()метод будет ожидать неопределенно долго, пока все задачи не будут завершены, в то время как invokeAny()метод будет ждать неопределенно долго,
пока хотя бы одна задача не завершится. ExecutorServiceИнтерфейс также включает
в себя перегруженные версии invokeAll()и invokeAny()что взять timeoutзначение и TimeUnitпараметр. Мы увидим, как использовать
эти типы параметров в следующем разделе при обсуждении 

Futureкласса. 

 В ожидании результатов
 
Как мы узнаем, когда задание, отправленное в, ExecutorServiceзавершено? Как упомянуто в последнем разделе, submit()метод возвращает java.util.concurrent.Future<V>объект,
или Future<V>для краткости, который может использоваться для определения этого результата:
Future<?> future = service.submit(() -> System.out.println("Hello Zoo"));
FutureКласс включает в себя методы , которые являются полезными при определении состояния задачи, как показано в таблице 7.3 .
Таблица 7.3 Future Методы


Method Name                                                                               	Описание
boolean
 isDone()                                                                          	Возвращает, trueесли задача была выполнена, вызвала исключение или была отменена.
boolean 
isCancelled()                                                                     	Возвращает, trueесли задание было отменено до того, как оно полностью прошло
boolean
 cancel()                                                                                      	Попытки отменить выполнение задания.
V get() 
                                                                                 Получает результат задачи, бесконечно ожидая, если она еще не доступна.


V get(long
 timeout, 
TimeUnit unit)                                                                      	Получает результат задачи, ожидая указанное количество времени.
                                                                                  Если результат не будет готов к моменту истечения времени ожидания,
                                                                                  TimeoutExceptionбудет выбрано проверенное .
                                                                                  
                                                                                  
Ниже приведена обновленная версия нашего более раннего примера CheckResultsкласса опроса , который использует Futureэкземпляр для опроса результатов:
import java.util.concurrent.*;
public class CheckResults {
   private static int counter = 0;
   public static void main(String[] args) throws InterruptedException,  
               ExecutionException {
   ExecutorService service = null;  
    try { 
        service = Executors.newSingleThreadExecutor();   
      Future<?> result = service.submit(() -> {   
         for(int i=0; i<500; i++) CheckResults.counter++;      
   });    
     result.get(10, TimeUnit.SECONDS); 
        System.out.println("Reached!"); 
     } catch (TimeoutException e) {  
       System.out.println("Not reached in time");  
    } finally {    
     if(service != null) service.shutdown();  
    }
   }}
Этот пример похож на нашу более раннюю реализацию опроса, но он не использует Threadкласс напрямую. Частично, это суть ConcurrencyAPI: делать сложные вещи
с потоками без Threadнепосредственного использования класса. Он также ожидает не более 10 секунд, выбрасывая, TimeoutExceptionесли задача не выполнена.
Какова возвращаемая стоимость этой задачи? Как Future<V>и универсальный класс, тип Vопределяется типом возвращаемого значения Runnableметода.
Поскольку возвращаемый тип Runnable.run()is void, get()метод всегда возвращается null. В следующем разделе вы увидите, что существует другой класс задач,
совместимый с ExecutorServiceдругими типами возвращаемых данных.
Как вы видели в предыдущем примере, get()метод может принимать необязательное значение и тип enum java.util.concurrent.TimeUnit.
Мы представляем полный список TimeUnitзначений в таблице 7.4 в порядке возрастания продолжительности. Обратите внимание, что многочисленные методы
в ConcurrencyAPI используют TimeUnitперечисление.

Таблица 7.4 TimeUnit значения


Enum Name	Описание
TimeUnit.NANOSECONDS	Время в одной миллиардной секунды (1/1 000 000 000)
TimeUnit.MICROSECONDS	Время в одной миллионной секунды (1/1 000 000)
TimeUnit.MILLISECONDS	Время в одну тысячную секунды (1/1000)
TimeUnit.SECONDS	Время в секундах
TimeUnit.MINUTES	Время в минутах
TimeUnit.HOURS	Время в часах
TimeUnit.DAYS	Время в днях

 4)Планирование задач
 
Зачастую в Java нам нужно запланировать задачу на будущее. Нам может даже потребоваться запланировать повторное выполнение задачи через определенный интервал.
Например, представьте, что мы хотим проверять запас корма для животных в зоопарке один раз в час и заполнять его по мере необходимости. 
The ScheduledExecutorService, который является подынтерфейсом ExecutorService, может использоваться как раз для такой задачи.
Например ExecutorService, мы получаем экземпляр ScheduledExecutorServiceиспользования фабричного метода в Executorsклассе, как показано в следующем фрагменте:
ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();
Обратите внимание, что мы можем неявно приводить экземпляр ScheduledExecutorServiceк ExecutorService, хотя это приведет к удалению доступа к запланированным методам,
которые мы хотим использовать.
Обратитесь к таблице 7.5 для нашего обсуждения ScheduledExecutorServiceметодов.

Таблица 7.5 ScheduledExecutorService методы

Method Name	                                                                        Описание
schedule(Callable<V> callable, long delay, TimeUnit unit)                       	Создает и выполняет Callableзадачу после заданной задержки
schedule(Runnable command, long delay, TimeUnit unit)                                  	Создает и выполняет Runnableзадачу после заданной задержки
scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)	Создает и выполняет Runnableзадачу после заданной начальной задержки,
                                                                                      создавая новую задачу при каждом проходящем значении периода.

scheduleAtFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)	Создает и выполняет Runnableзадачу после заданной начальной задержки, 
                                                                                     а затем с заданной задержкой между прекращением одного выполнения и началом следующего

!!!На практике эти методы являются одними из самых удобных в ConcurrencyAPI, поскольку они выполняют относительно сложные задачи с помощью одной строки кода.

Параметры delay и period используют TimeUnitаргумент для определения формата значения, например, секунд или миллисекунд.
Первые два schedule()метода в Таблице 7.5 принимают Callableили Runnable, соответственно, выполняют задачу после некоторой задержки и возвращают ScheduledFuture<V> экземпляр.
ScheduledFuture<V>идентичен Future<V>классу, за исключением того, что он включает getDelay()метод, который возвращает задержку, установленную при создании процесса.
Далее используется schedule()метод с Callableи Runnableзадачами:

ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();
Runnable task1 = () -> System.out.println("Hello Zoo");
Callable<String> task2 = () -> "Monkey";
Future<?> result1 = service.schedule(task1, 10, TimeUnit.SECONDS);
Future<?> result2 = service.schedule(task2, 8, TimeUnit.MINUTES);

Первое задание запланировано на 10 секунд в будущем, тогда как второе задание запланировано на 8 минут в будущем. 

   Хотя эти задачи запланированы на будущее, фактическое выполнение может быть отложено. Например, могут быть недоступны потоки для выполнения задачи,
   и в этот момент они просто будут ждать в очереди. Кроме того, если ScheduledExecutorServiceк моменту достижения запланированного времени выполнения
   задачи оно будет отключено, они будут отброшены.
Последние два метода в Таблице 7.5 могут немного сбить с толку, если вы их раньше не видели.
Концептуально они очень похожи, так как они выполняют одну и ту же задачу несколько раз после завершения некоторой начальной задержки. 
Разница связана со сроками процесса и началом следующей задачи.
scheduleAtFixedRate()Метод создает новую задачу и передает его исполнителю за каждый период, независимо от того , или не закончили предыдущее задание.
В следующем примере Runnableзадача выполняется каждую минуту после первоначальной пятиминутной задержки:
service.scheduleAtFixedRate(command,5,1,TimeUnit.MINUTE);
Одним из рисков использования этого метода является вероятность того, что задача может последовательно выполняться дольше, чем период между задачами.
Что произойдет, если выполнение задачи последовательно занимает пять минут? Несмотря на то, что задача все еще выполняется,
ScheduledExecutorServiceбудет отправляться новая задача, которая будет запускаться каждую минуту. Если использовался однопотоковый исполнитель,
со временем это привело бы к планированию бесконечных заданных задач, которые выполнялись бы подряд, предполагая,
что никакие другие задачи не были переданы ScheduledExecutorService.
С другой стороны, scheduleAtFixedDelay()метод создает новую задачу после завершения предыдущей задачи.
Например, если первое задание выполняется в 12:00 и для его завершения требуется пять минут с периодом в 2несколько минут, то второе задание запускается в 12:07.

service.scheduleAtFixedDelay(command,0,2,TimeUnit.MINUTE);
Обратите внимание, что ни один из методов, scheduleAtFixedDelay()и scheduleAtFixedRate(), не принимают Callableобъект в качестве входного параметра.
Поскольку эти задачи планируется выполнять бесконечно, пока ScheduledExecutorServiceони еще живы, они будут генерировать бесконечную серию Futureобъектов.
Каждый из этих ScheduledExecutorServiceметодов важен и имеет практическое применение. Например, вы можете использовать schedule()команду 
для проверки состояния обработки задачи и отправки уведомлений, если она еще не завершена, или даже schedule()снова вызвать задержку обработки.
Это scheduleAtFixedRate()полезно для задач, которые необходимо выполнять через определенные промежутки времени, например, для проверки здоровья животных один раз в день.
Даже если для изучения животного в понедельник требуется два часа, это не означает, что экзамен во вторник должен начаться позже.
Наконец, scheduleAtFixedDelay()это полезно для процессов, которые вы хотите повторять, но чье время не имеет значения. Например,
представьте, что у нас есть работник кафетерия в зоопарке, который периодически пополняет салат-бар в течение дня.
Процесс может занять 20 минут и более, так как он требует, чтобы работник забрал большое количество предметов из задней комнаты.
После того, как работник наполнил салат-бар свежей едой, ему не нужно проверять в определенное время, только после того, как прошло достаточно времени, 
чтобы он снова стал нехватать товар.
Если вы знакомы с созданием заданий Cron в Linux для планирования задач, то вы должны знать, что scheduleAtFixedRate()это самый близкий встроенный эквивалент Java. 

Увеличение параллелизма с пулами

Все наши примеры до сих пор были с однопоточными исполнителями, которые, хотя и были интересны, не были особенно полезны.
В конце концов, эта глава называется «Параллелизм», и вы не можете сделать это с помощью однопотокового исполнителя!
Теперь мы представим три дополнительных метода фабрики в Executorsклассе, которые действуют на пул потоков, а не на один поток.
A thread pool- это группа предварительно созданных многократно используемых потоков, которые доступны для выполнения набора произвольных задач.

Таблица 7.6 включает в себя два предыдущих метода однопотокового исполнителя, а также новые, которые вы должны знать для экзамена.

Таблица 7.6. Executors Методы

Method Name                        	                    Return                                                                                Type	Описание
newSingleThreadExecutor()	                        ExecutorService                       	Создает однопоточный исполнитель, который использует один рабочий поток, 
работающий из неограниченной очереди. Результаты обрабатываются последовательно в том порядке, в котором они представлены.

newSingleThreadScheduled Executor()	                 Scheduled ExecutorService                    	Создает однопоточный исполнитель, который может запланировать
выполнение команд после заданной задержки или периодическое выполнение.

newCachedThreadPool()	                               ExecutorService	                       Создает пул потоков, который создает новые потоки по мере необходимости,
но будет повторно использовать ранее созданные потоки, когда они станут доступны.

newFixedThreadPool(int nThreads)                       	ExecutorService                       	Создает пул потоков, который повторно использует фиксированное число потоков,
работающих в общей неограниченной очереди.
newScheduledThreadPool(int nThreads)	Scheduled ExecutorService	Создает пул потоков, который может запланировать выполнение команд после заданной
задержки или периодическое выполнение.

Как показано в таблице 7.6 , эти методы возвращают те же типы экземпляров, ExecutorServiceи ScheduledExecutorService, что мы использовали ранее в этой главе.
Другими словами, все наши предыдущие примеры совместимы с этими новыми исполнителями пула потоков! Есть также перегруженные версии каждого из методов в Таблице 7.6,
которые создают потоки, используя ThreadFactoryвходной параметр. Для экзамена вам нужно только знать методы создания исполнителей потоков в таблице 7.6 .
Разница между однопоточным исполнителем и исполнителем пула состоит в том, что происходит, когда задача уже выполняется. В то время как однопоточный исполнитель будет ждать,
пока доступный поток станет доступным, прежде чем запускать следующую задачу, исполнитель пула потоков можетвыполнить следующую задачу одновременно.
Если в пуле заканчиваются доступные потоки, задача будет поставлена в очередь исполнителем потока и будет ждать завершения.
newCachedThreadPool()Метод создание пула потоков неограниченного размера, выделяя новую нить в любое время один требуются или все существующие потоки заняты.
Это обычно используется для пулов, которые требуют выполнения многих краткосрочных асинхронных задач.
Для долгоживущих процессов использование этого исполнителя категорически не рекомендуется, 
так как он может вырасти и охватить большое количество потоков в течение жизненного цикла приложения.
Он newFixedThreadPool()принимает несколько потоков и распределяет их все при создании.
Пока наше количество задач меньше количества потоков, все задачи будут выполняться одновременно.
Если в какой-то момент количество задач превысит количество потоков в пуле, они будут ждать так же, как вы видели с однопоточным исполнителем.
На самом деле, вызов newFixedThreadPool()со значением 1эквивалентен вызову newSingleThreadExecutor().
Метод newScheduledThreadPool()идентичен newFixedThreadPool()методу, за исключением того, что он возвращает экземпляр ScheduledExecutorServiceи поэтому совместим
с задачами планирования. Этот исполнитель имеет тонкие различия в том, как scheduleAtFixedRate()выполняет. Например, вспомните наш предыдущий пример,
в котором задачи выполнялись пять минут:

ScheduledExecutorService service = Executors.newScheduledThreadPool(10);
service.scheduleAtFixedRate(command,3,1,TimeUnit.MINUTE);
В то время как с однопоточным исполнителем и пятиминутным временем выполнения задачи со временем будет запланирован бесконечный набор задач.
С объединенным исполнителем этого можно избежать. Если размер пула достаточно велик, например, 10, то по завершении каждого потока он возвращается в пул и
приводит к появлению новых потоков, доступных для следующих задач по мере их появления.

 Выбор размера бассейна
На практике может быть довольно трудно выбрать подходящий размер пула. В общем, вы хотите по крайней мере несколько потоков, чем вы, возможно,
когда-либо понадобятся. С другой стороны, вы не хотите выбирать столько потоков, чтобы ваше приложение использовало слишком много ресурсов
или слишком много ресурсов процессора. Часто число доступных процессоров используется для определения размера потока с помощью этой команды:
Runtime.getRuntime().availableProcessors()
Распространенной практикой является выделение пулов потоков в зависимости от количества процессоров, а также интенсивности загрузки процессора.
Например, если вы выполняете задачи с высокой загрузкой процессора, то создание 16-потокового пула на компьютере с 2 процессорами приведет к тому,
что компьютер будет работать довольно медленно, поскольку ваш процесс поглощает большую часть пропускной способности процессора, доступной длядругие приложения.
В качестве альтернативы, если ваши задачи включают в себя чтение / запись данных с диска или из сети, может быть уместен пул из 16 потоков,
поскольку большая часть ожидания требует внешних ресурсов.
К счастью, большинство задач зависят от некоторых других ресурсов, таких как база данных, файловая система или сеть.
В таких ситуациях создание больших пулов потоков, как правило, безопасно, так как задачи не нагружают процессор и могут потребовать много времени
для ожидания доступности внешних ресурсов.

